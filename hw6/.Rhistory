mod = my.model(p,q,P,Q)
if (mod$mse < best.mse) {
best.mse = mod$mse
best.param = c(p,q,P,Q)
}
}
}
}
}
best.param = rep(-1, 4)
best.p = -1
best.q = -1
best.P = -1
best.Q = -1
best.mse = 9999
for (p in 0:3) {
for (q in 0:3) {
for (P in 0:1) {
for (Q in 0:1) {
mod = my.model(p,q,P,Q)
if (mod$mse < best.mse) {
best.mse = mod$mse
best.param = c(p,q,P,Q)
}
}
}
}
}
best.mse
best.param
best.mod = my.model(2,2,0,0)
plot(c(r, best.mod$r.pred), type = "l")
abline(v=length(r), col='red')
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
ave.filter = c(1/24, rep(1/12, 11), 1/24)
trend = stats::filter(ytrain, filter=ave.filter)
plot(trend, type='l')
log.post.omega <- function(omega) { # log of posterior distribution
X = matrix(1, nrow=ntrain, ncol=3)
X[,2] = cos(omega*(1:ntrain))
X[,3] = sin(omega*(1:ntrain))
mod = lm(ytrain ~ -1 + X)
log.post = (ncol(X) - n)/2*log(sum(mod$residuals^2)) - 0.5*log(det(t(X) %*% X))
log.post
}
omega.hat = optimize(log.post.omega, interval=c(2*pi/190, 2*pi/170), maximum=T)$maximum
X = matrix(1, nrow=ntrain, ncol=3)
X[,2] = cos(omega.hat*(1:ntrain))
X[,3] = sin(omega.hat*(1:ntrain))
linmod = lm(ytrain ~ -1 + X)
linmod$coefficients
plot(ytrain, type='l')
lines(linmod$fitted.values, col='red')
r = linmod$residuals
plot(r, type='l')
acf(r) # spike at 12 -> seasonal trend
r = linmod$residuals
plot(r, type='l')
acf(r) # spike at 12 -> yearly trend
rd = diff(r, lag=12)
plot(rd, type='l')
acf(rd)
pacf(rd)
best.param
best.mse
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
2*pi/omega.hat
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
dat = read.csv('hiking.csv', header=T, skip=1)
y = dat[,2]
n = length(y)
ntrain = n-ntest
ytrain = y[1:ntrain]
ytest = y[(ntrain+1):n]
plot(ytrain, type='l')
acf(ytrain)
ave.filter = c(1/24, rep(1/12, 11), 1/24)
trend = stats::filter(ytrain, filter=ave.filter)
plot(trend, type='l')
log.post.omega <- function(omega) { # log of posterior distribution
X = matrix(1, nrow=ntrain, ncol=3)
X[,2] = cos(omega*(1:ntrain))
X[,3] = sin(omega*(1:ntrain))
mod = lm(ytrain ~ -1 + X)
log.post = (ncol(X) - n)/2*log(sum(mod$residuals^2)) - 0.5*log(det(t(X) %*% X))
log.post
}
omega.hat = optimize(log.post.omega, interval=c(2*pi/190, 2*pi/170), maximum=T)$maximum
2*pi/omega.hat
X = matrix(1, nrow=ntrain, ncol=3)
X[,2] = cos(omega.hat*(1:ntrain))
X[,3] = sin(omega.hat*(1:ntrain))
linmod = lm(ytrain ~ -1 + X)
linmod$coefficients
plot(linmod$fitted.values, type='l')
plot(ytrain, type='l')
lines(linmod$fitted.values, col='red')
plot(linmod$residuals, type='l')
r = linmod$residuals
rd = diff(r, 12)
plot(rd, type='l')
acf(rd)
pacf(rd)
my.model = function(p,q,P,Q) {
r.mod = arima(r, order=c(p, 0, q), seasonal=list(order=c(P,1,Q), period=12))
r.pred = predict(r.mod, n.ahead=ntest)$pred %>% as.numeric()
trend.coef = linmod$coefficients %>% as.numeric()
pred.time = (ntrain+1):n
trend.pred = trend.coef[1] + trend.coef[2]*cos(pred.time) + trend.coef[3]*sin(pred.time)
pred = r.pred + trend.pred
mse = mean((ytest - pred)^2)
return( list(pred=pred, mse=mse, r.pred=r.pred) )
}
best.param = rep(-1, 4)
best.mse = 9999
for (p in 0:3) {
for (q in 0:3) {
for (P in 0:1) {
for (Q in 0:1) {
mod = my.model(p,q,P,Q)
if (mod$mse < best.mse) {
best.mse = mod$mse
best.param = c(p,q,P,Q)
}
}
}
}
}
best.param
best.param
best.mse
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
my.model = function(p,q,P,Q) {
r.mod = arima(r, order=c(p, 0, q), seasonal=list(order=c(P,1,Q), period=12))
r.pred = predict(r.mod, n.ahead=ntest)$pred %>% as.numeric()
trend.coef = linmod$coefficients %>% as.numeric()
pred.time = (ntrain+1):n
trend.pred = trend.coef[1] + trend.coef[2]*cos(pred.time) + trend.coef[3]*sin(pred.time)
pred = r.pred + trend.pred
mse = mean((ytest - pred)^2)
return( list(pred=pred, mse=mse, r.pred=r.pred) )
}
best.param
best.mse
p = best.param[1]; q = best.param[2]; P = best.param[3]; Q = best.param[4];
best.mod = my.model(p,q,P,Q)
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
dat = read.csv('hiking.csv', header=T, skip=1)
y = dat[,2]
n = length(y)
ntrain = n-ntest
ytrain = y[1:ntrain]
ytest = y[(ntrain+1):n]
plot(ytrain, type='l')
log.post.omega <- function(omega) { # log of posterior distribution
X = matrix(1, nrow=ntrain, ncol=3)
X[,2] = cos(omega*(1:ntrain))
X[,3] = sin(omega*(1:ntrain))
mod = lm(ytrain ~ -1 + X)
log.post = (ncol(X) - n)/2*log(sum(mod$residuals^2)) - 0.5*log(det(t(X) %*% X))
log.post
}
omega.hat = optimize(log.post.omega, interval=c(2*pi/190, 2*pi/170), maximum=T)$maximum
X = matrix(1, nrow=ntrain, ncol=3)
X[,2] = cos(omega.hat*(1:ntrain))
X[,3] = sin(omega.hat*(1:ntrain))
linmod = lm(ytrain ~ -1 + X)
linmod$coefficients
plot(ytrain, type='l')
lines(linmod$fitted.values, col='red')
r = linmod$residuals
rd = diff(r, 12)
plot(rd, type='l')
my.model = function(p,q,P,Q) {
r.mod = arima(r, order=c(p, 0, q), seasonal=list(order=c(P,1,Q), period=12))
r.pred = predict(r.mod, n.ahead=ntest)$pred %>% as.numeric()
trend.coef = linmod$coefficients %>% as.numeric()
pred.time = (ntrain+1):n
trend.pred = trend.coef[1] + trend.coef[2]*cos(pred.time) + trend.coef[3]*sin(pred.time)
pred = r.pred + trend.pred
mse = mean((ytest - pred)^2)
return( list(pred=pred, mse=mse, r.pred=r.pred) )
}
best.param = rep(-1, 4)
best.mse = 9999
for (p in 0:3) {
for (q in 0:3) {
for (P in 0:1) {
for (Q in 0:1) {
mod = my.model(p,q,P,Q)
if (mod$mse < best.mse) {
best.mse = mod$mse
best.param = c(p,q,P,Q)
}
}
}
}
}
best.param
best.mse
p = best.param[1]; q = best.param[2]; P = best.param[3]; Q = best.param[4];
best.mod = my.model(p,q,P,Q)
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
plot(c(r,best.mod$r.pred), type='l')
plot(c(linmod$fitted.values, best.mod$pred-best.mod$r.pred), type='l')
my.model = function(p,q,P,Q) {
r.mod = arima(r, order=c(p, 0, q), seasonal=list(order=c(P,1,Q), period=12))
r.pred = predict(r.mod, n.ahead=ntest)$pred %>% as.numeric()
trend.coef = linmod$coefficients %>% as.numeric()
pred.time = (ntrain+1):n
trend.pred = trend.coef[1] + trend.coef[2]*cos(omega.hat*pred.time) + trend.coef[3]*sin(omega.hat*pred.time)
pred = r.pred + trend.pred
mse = mean((ytest - pred)^2)
return( list(pred=pred, mse=mse, r.pred=r.pred) )
}
best.param = rep(-1, 4)
best.mse = 9999
for (p in 0:3) {
for (q in 0:3) {
for (P in 0:1) {
for (Q in 0:1) {
mod = my.model(p,q,P,Q)
if (mod$mse < best.mse) {
best.mse = mod$mse
best.param = c(p,q,P,Q)
}
}
}
}
}
best.param
best.mse
p = best.param[1]; q = best.param[2]; P = best.param[3]; Q = best.param[4];
best.mod = my.model(p,q,P,Q)
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
dat = read.csv('algebra.csv', header=T, skip=1)
y = dat[,2]
n = length(y)
ntrain = n-ntest
ytrain = y[1:ntrain]
ytest = y[(ntrain+1):n]
plot(ytrain, type='l')
ave.filter = c(1/24, rep(1/12, 11), 1/24)
trend = stats::filter(ytrain, filter=ave.filter)
plot(trend, type='l')
log.post.omega <- function(omega) { # log of posterior distribution
X = matrix(1, nrow=ntrain, ncol=3)
X[,2] = cos(omega*(1:ntrain))
X[,3] = sin(omega*(1:ntrain))
mod = lm(ytrain ~ -1 + X)
log.post = (ncol(X) - n)/2*log(sum(mod$residuals^2)) - 0.5*log(det(t(X) %*% X))
log.post
}
omega.hat = optimize(log.post.omega, interval=c(2*pi/190, 2*pi/170), maximum=T)$maximum
X = matrix(1, nrow=ntrain, ncol=3)
X[,2] = cos(omega.hat*(1:ntrain))
X[,3] = sin(omega.hat*(1:ntrain))
linmod = lm(ytrain ~ -1 + X)
linmod$coefficients
r = linmod$residuals
plot(r, type='l')
acf(r) # spike at 12 -> yearly trend
rd = diff(r, lag=12)
acf(rd)
pacf(rd)
my.model = function(p,q,P,Q) {
r.mod = arima(r, order=c(p, 0, q), seasonal=list(order=c(P,1,Q), period=12))
r.pred = predict(r.mod, n.ahead=ntest)$pred %>% as.numeric()
trend.coef = linmod$coefficients %>% as.numeric()
pred.time = (ntrain+1):n
trend.pred = trend.coef[1] + trend.coef[2]*cos(omega.hat*pred.time) + trend.coef[3]*sin(omega.hat*pred.time)
pred = r.pred + trend.pred
mse = mean((ytest - pred)^2)
return( list(pred=pred, mse=mse, r.pred=r.pred) )
}
best.param = rep(-1, 4)
best.mse = 9999
for (p in 0:3) {
for (q in 0:3) {
for (P in 0:1) {
for (Q in 0:1) {
mod = my.model(p,q,P,Q)
if (mod$mse < best.mse) {
best.mse = mod$mse
best.param = c(p,q,P,Q)
}
}
}
}
}
best.param
best.mse
p = best.param[1]; q = best.param[2]; P = best.param[3]; Q = best.param[4];
best.mod = my.model(p,q,P,Q)
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
plot(c(linmod$fitted.values, best.mod$pred-best.mod$r.pred), type='l')
mod1010 = my.model(1,0,1,0)
plot(1:n, y, type='l')
lines((ntrain+1):n, mod1010$pred, col='red')
dat = read.csv('hiking.csv', header=T, skip=1)
y = dat[,2]
n = length(y)
ntrain = n-ntest
ytrain = y[1:ntrain]
ytest = y[(ntrain+1):n]
plot(ytrain, type='l')
log.post.omega <- function(omega) { # log of posterior distribution
X = matrix(1, nrow=ntrain, ncol=3)
X[,2] = cos(omega*(1:ntrain))
X[,3] = sin(omega*(1:ntrain))
mod = lm(ytrain ~ -1 + X)
log.post = (ncol(X) - n)/2*log(sum(mod$residuals^2)) - 0.5*log(det(t(X) %*% X))
log.post
}
omega.hat = optimize(log.post.omega, interval=c(2*pi/190, 2*pi/170), maximum=T)$maximum
2*pi/omega.hat
X = matrix(1, nrow=ntrain, ncol=3)
X[,2] = cos(omega.hat*(1:ntrain))
X[,3] = sin(omega.hat*(1:ntrain))
linmod = lm(ytrain ~ -1 + X)
linmod$coefficients
plot(ytrain, type='l')
lines(linmod$fitted.values, col='red')
r = linmod$residuals
rd = diff(r, 12)
plot(rd, type='l')
best.param # surprising. Not 1 0 1 0?
best.mse
my.model = function(p,q,P,Q) {
r.mod = arima(r, order=c(p, 0, q), seasonal=list(order=c(P,1,Q), period=12))
r.pred = predict(r.mod, n.ahead=ntest)$pred %>% as.numeric()
trend.coef = linmod$coefficients %>% as.numeric()
pred.time = (ntrain+1):n
trend.pred = trend.coef[1] + trend.coef[2]*cos(omega.hat*pred.time) + trend.coef[3]*sin(omega.hat*pred.time)
pred = r.pred + trend.pred
mse = mean((ytest - pred)^2)
return( list(pred=pred, mse=mse, r.pred=r.pred) )
}
best.param = rep(-1, 4)
best.mse = 9999
for (p in 0:3) {
for (q in 0:3) {
for (P in 0:1) {
for (Q in 0:1) {
mod = my.model(p,q,P,Q)
if (mod$mse < best.mse) {
best.mse = mod$mse
best.param = c(p,q,P,Q)
}
}
}
}
}
best.param # surprising. Not 1 0 1 0?
best.mse
p = best.param[1]; q = best.param[2]; P = best.param[3]; Q = best.param[4];
best.mod = my.model(p,q,P,Q)
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
mod1010 = my.model(1,0,1,0)
plot(1:n, y, type='l')
lines((ntrain+1):n, mod1010$pred, col='red')
mod1010 = my.model(1,0,1,0)
plot(1:n, y, type='l')
lines((ntrain+1):n, mod1010$pred, col='red')
mod1010$mse
best.param # surprising. Not 1 0 1 0?
best.mse
mod1010 = my.model(1,0,1,0)
plot(1:n, y, type='l')
lines((ntrain+1):n, mod1010$pred, col='red')
mod1010$mse
best.param # Not 1 0 1 0
best.mse
dat = read.csv('tutoring.csv', header=T, skip=1)
y = dat[,2]
n = length(y)
ntest = 36
ntrain = n-ntest
ytrain = y[1:ntrain]
ytest = y[(ntrain+1):n]
plot(ytrain, type='l')
plot(ytrain[150:ntrain], type='l')
acf(ytrain)
ntrain %/% 12
m = ntrain %/% 12
ave = rep(-9999, m)
for (k in 1:m) {
ave[k] = ytrain[(12*k-11):(12*k)]
}
plot(ave, type='l')
ave.filter = c(1/24, rep(1/12, 11), 1/24)
trend = stats::filter(ytrain, filter=ave.filter)
plot(trend, type='l')
m = ntrain %/% 12
ave = rep(-9999, m)
amp = rep(-9999, m) # oscillation amplitude in that year
for (k in 1:m) {
z = ytrain[(12*k-11):(12*k)]
ave[k] = mean(z)
amp[k] = max(z) - min(z)
}
plot(ave, type='l')
m = ntrain %/% 12
ave = rep(-9999, m)
amp = rep(-9999, m) # oscillation amplitude in that year
for (k in 1:m) {
z = ytrain[(12*k-11):(12*k)]
ave[k] = mean(z)
amp[k] = max(z) - min(z)
}
plot(amp, type='l')
period=12
moving.amp = rep(-9999, ntrain-period)
for (k in 1:length(moving.amp)) {
z = ytrain[k:(k+period)]
moving.amp[k] = max(z) - min(z)
}
period=12
moving.amp = rep(-9999, ntrain-period)
for (k in 1:length(moving.amp)) {
z = ytrain[k:(k+period)]
moving.amp[k] = max(z) - min(z)
}
plot(moving.amp, type='l')
moving.amp.lm = lm(moving.amp ~ c(1:length(moving.amp)))
plot(moving.amp.lm$residual, type='l')
yd = diff(ytrain, 12)
plot(yd, type='l')
acf(yd)
pacf(yd)
my.model = function(p,q,P,Q) {
mod = arima(ytrain, order=c(p, 0, q), seasonal=list(order=c(P,1,Q), period=12))
pred = predict(mod, n.ahead=ntest)$pred %>% as.numeric()
mse = mean((ytest - pred)^2)
return( list(pred=pred, mse=mse) )
}
best.param = rep(-1, 4)
best.mse = 9999
for (p in 0:3) {
for (q in 0:3) {
for (P in 0:1) {
for (Q in 0:1) {
mod = my.model(p,q,P,Q)
if (mod$mse < best.mse) {
best.mse = mod$mse
best.param = c(p,q,P,Q)
}
}
}
}
}
dat = read.csv('tutoring.csv', header=T, skip=1)
y = dat[,2]
n = length(y)
ntest = 36
ntrain = n-ntest
ytrain = y[1:ntrain]
ytest = y[(ntrain+1):n]
plot(ytrain, type='l')
my.model = function(p,q,P,Q) {
mod = arima(ytrain, order=c(p, 0, q), seasonal=list(order=c(P,1,Q), period=12))
pred = predict(mod, n.ahead=ntest)$pred %>% as.numeric()
mse = mean((ytest - pred)^2)
return( list(pred=pred, mse=mse) )
}
best.param = rep(-1, 4)
best.mse = 9999
for (p in 0:3) {
for (q in 0:3) {
for (P in 0:1) {
for (Q in 0:1) {
mod = my.model(p,q,P,Q)
if (mod$mse < best.mse) {
best.mse = mod$mse
best.param = c(p,q,P,Q)
}
}
}
}
}
best.param
p = best.param[1]; q = best.param[2]; P = best.param[3]; Q = best.param[4];
best.mod = my.model(p,q,P,Q)
plot(1:n, y, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
p = best.param[1]; q = best.param[2]; P = best.param[3]; Q = best.param[4];
best.mod = my.model(p,q,P,Q)
plot((ntrain+1):n, ytest, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
plot((ntrain+1):n, ytest, type='l')
lines((ntrain+1):n, my.model(0,1,1,0)$pred, col='red') # MA(1) + seasonal AR(1)
best.param
best.mse
my.model(0,1,1,0)$mse
my.model(3,0,1,0)$mse
best.param
best.mse
p = best.param[1]; q = best.param[2]; P = best.param[3]; Q = best.param[4];
best.mod = my.model(p,q,P,Q)
plot((ntrain+1):n, ytest, type='l')
lines((ntrain+1):n, best.mod$pred, col='red')
