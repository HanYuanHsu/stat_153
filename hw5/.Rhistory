dat = read.delim("sunspot.txt", header = F, sep = "")
y = dat[,2]
dat = read.delim("sunspot.txt", header = F, sep = "")
y = dat[,2]
n = length(y)
sum(y<0)
acf(y)
pacf(y)
plot(1:n, y, type='l')
ntest=40
ytrain = y[1:(n-ntest)]
ytest = y[(n-ntest+1):n]
ntest=40
ntrain=n-ntest
ytrain = y[1:(n-ntest)]
ytest = y[(n-ntest+1):n]
ar.pred = matrix(-9999, nrow=ntest, ncol=15) # column p is predictions of AR(p) model
for (p in 1:15) {
Xmat = matrix(nrow=ntrain-p, ncol=p)
for(j in 1:p)
{
Xmat[,j] = ytrain[(p-j+1):(ntrain-j)]
}
modar = lm(ytrain[(p+1):ntrain] ~ Xmat)
# make predictions
y.full = c(y, rep(-9999, ntest))
phis = modar$coefficients %>% as.numeric()
for (t in (ntrain+1):n) {
y.full[t] = sum(phis * c(1, y.full[(t-1):(t-p)]))
}
ar.pred[,p] = y.full[(ntrain+1):n]
}
ar.pred
ntest=40
ntrain=n-ntest
ytrain = y[1:(n-ntest)]
ytest = y[(n-ntest+1):n]
ar.pred = matrix(-9999, nrow=ntest, ncol=15) # column p is predictions of AR(p) model
ar.mse = rep(-1, 15)
for (p in 1:15) {
Xmat = matrix(nrow=ntrain-p, ncol=p)
for(j in 1:p)
{
Xmat[,j] = ytrain[(p-j+1):(ntrain-j)]
}
modar = lm(ytrain[(p+1):ntrain] ~ Xmat)
# make predictions
y.full = c(y, rep(-9999, ntest))
phis = modar$coefficients %>% as.numeric()
for (t in (ntrain+1):n) {
y.full[t] = sum(phis * c(1, y.full[(t-1):(t-p)]))
}
ar.pred[,p] = y.full[(ntrain+1):n]
# calculate mse
ar.mse[p] = mean((ytest - ar.pred[,p])^2)
}
which.min(ar.mse)
dat = read.csv('alc.csv')
y = dat[,2]
n = length(y)
plot(1:n, y, type='l')
p = 16
Xmat = matrix(nrow=n-p, ncol=p)
for(j in 1:p)
{
Xmat[,j] = y[(p-j+1):(n-j)]
}
modar = lm(y[(p+1):n] ~ Xmat)
summary(modar)
k = 36
y.full = c(y, rep(-9999, k))
phis = modar$coefficients %>% as.numeric()
for (t in (n+1):(n+k)) {
y.full[t] = sum(phis * c(1, y.full[(t-1):(t-p)]))
}
start=250
plot(start:n, y[start:n], type='l', xlim=c(start-1,n+k), ylim=c(3000, 8500))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
ntrain=300
ntest=n-ntrain
ytrain = y[1:ntrain]
ytest = y[(ntrain+1):n]
q=20
ma = arima(ytrain, order=c(0,0,q), method='CSS')
ma.pred = predict(ma, n.ahead=ntest)$pred
plot(1:n, y, type='l')
lines((ntrain+1):n, ma.pred, col='red')
linmod = lm(ytrain ~ c(1:ntrain))
lin.coeff = linmod$coefficients %>% as.numeric()
lin.pred = lin.coeff[1] + lin.coeff[2]*c((ntrain+1):n)
lin.mse = mean((ytest - lin.pred)^2) # mean square error
lin.mse
#plot(1:n, y, type='l')
#lines((ntrain+1):n, lin.pred, col='red')
Dt = diff(diff(y, lag= 12))
#length(Dt) # n-13
plot(1:length(Dt), Dt, type='l')
acf(Dt)
ma1 = arima(Dt, order=c(0,0,1), method='CSS')
ma1
mu = ma1$coef[2] %>% as.numeric(); th = ma1$coef[1] %>% as.numeric()
psi0 = mu * (1-th+th^2-th^3)
psi1 = th
psi2 = -th^2
psi3 = th^3
c(psi0, psi1, psi2, psi3)
mu
mean(Dt)
d.coef = rep(0, p+1) # coefficients for the second AR(16) model derived from Dt. The first entry is the intercept.
d.coef[1] = psi0
d.coef[2] = 1+psi1
d.coef[3] = psi2-psi1
d.coef[4] = psi3-psi2
d.coef[5] = -psi3
d.coef[13] = 1
d.coef[14] = 1-psi1
d.coef[15] = psi1-psi2
d.coef[16] = psi2-psi3
d.coef[17] = psi3
d.coef
modar$coefficients
k = 36
y.full2 = c(y, rep(-9999, k))
for (t in (n+1):(n+k)) {
y.full2[t] = sum(d.coef * c(1, y.full2[(t-1):(t-p)]))
}
# explodes... strange...
y.full2[(n+1):(n+k)]
plot(1:n, y, type='l', xlim=c(0,n+k), ylim=c(0, 6563533.29))
#lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
lines((n+1):(n+k), y.full2[(n+1):(n+k)], col='blue')
psi0 = mu * (1-th+th^2-th^3)
psi1 = th
psi2 = -th^2
psi3 = th^3
c(psi0, psi1, psi2, psi3)
mu
mean(Dt)
d.coef = rep(0, p+1) # coefficients for the second AR(16) model derived from Dt. The first entry is the intercept.
d.coef[1] = psi0
d.coef[2] = 1+psi1
d.coef[3] = psi2-psi1
d.coef[4] = psi3-psi2
d.coef[5] = -psi3
d.coef[13] = 1
d.coef[14] = -1-psi1
d.coef[15] = psi1-psi2
d.coef[16] = psi2-psi3
d.coef[17] = psi3
d.coef
modar$coefficients
k = 36
y.full2 = c(y, rep(-9999, k))
for (t in (n+1):(n+k)) {
y.full2[t] = sum(d.coef * c(1, y.full2[(t-1):(t-p)]))
}
# explodes... strange...
y.full2[(n+1):(n+k)]
plot(1:n, y, type='l', xlim=c(0,n+k))
#lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
lines((n+1):(n+k), y.full2[(n+1):(n+k)], col='blue')
plot(1:n, y, type='l', xlim=c(0,n+k))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
lines((n+1):(n+k), y.full2[(n+1):(n+k)], col='blue')
dat = read.csv('yield.csv')
y = dat[,2]
n = length(y)
plot(1:n, y, type='l')
p = 4
Xmat = matrix(nrow=n-p, ncol=p)
for(j in 1:p)
{
Xmat[,j] = y[(p-j+1):(n-j)]
}
modar = lm(y[(p+1):n] ~ Xmat)
summary(modar)
k = 100
y.full = c(y, rep(-9999, k))
phis = modar$coefficients %>% as.numeric()
for (t in (n+1):(n+k)) {
y.full[t] = sum(phis * c(1, y.full[t-1], y.full[t-2], y.full[t-3], y.full[t-4]))
}
plot(1:n, y, type='l', xlim=c(0,n+k))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
acf(y)
mean(y)
mean(y)
y.full[n+k]
y.full = c(y, rep(-9999, 500))
phis = modar$coefficients %>% as.numeric()
for (t in (n+1):(n+500)) {
y.full[t] = sum(phis * c(1, y.full[t-1], y.full[t-2], y.full[t-3], y.full[t-4]))
}
mean(y)
y.full[n+500]
K=1000
y.full = c(y, rep(-9999, K))
phis = modar$coefficients %>% as.numeric()
for (t in (n+1):(n+K)) {
y.full[t] = sum(phis * c(1, y.full[t-1], y.full[t-2], y.full[t-3], y.full[t-4]))
}
mean(y)
y.full[n+K]
model.diff = y.full[(n+1):(n+k)] - y.full2[(n+1):(n+k)
plot(1:k, model.diff, type='l')
model.diff = y.full[(n+1):(n+k)] - y.full2[(n+1):(n+k)]
plot(1:k, model.diff, type='l')
model.diff = y.full[(n+1):(n+k)] - y.full2[(n+1):(n+k)]
model.diff
#plot(1:k, model.diff, type='l')
mu.hat = ma1$coef['intercept'] %>% as.numeric()
theta.hat = ma1$coef['ma1'] %>% as.numeric()
psi0 = mu.hat * (1-theta.hat+theta.hat^2-theta.hat^3)
psi1 = theta.hat
psi2 = -theta.hat^2
psi3 = theta.hat^3
c(psi0, psi1, psi2, psi3)
dat = read.csv('yield.csv')
y = dat[,2]
n = length(y)
plot(1:n, y, type='l')
p = 4
Xmat = matrix(nrow=n-p, ncol=p)
for(j in 1:p)
{
Xmat[,j] = y[(p-j+1):(n-j)]
}
modar = lm(y[(p+1):n] ~ Xmat)
summary(modar)
k = 100
y.full = c(y, rep(-9999, k))
phis = modar$coefficients %>% as.numeric()
for (t in (n+1):(n+k)) {
y.full[t] = sum(phis * c(1, y.full[t-1], y.full[t-2], y.full[t-3], y.full[t-4]))
}
plot(1:n, y, type='l', xlim=c(0,n+k))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
K=1000
y.full = c(y, rep(-9999, K))
phis = modar$coefficients %>% as.numeric()
for (t in (n+1):(n+K)) {
y.full[t] = sum(phis * c(1, y.full[t-1], y.full[t-2], y.full[t-3], y.full[t-4]))
}
mean(y)
y.full[n+K]
y.diff = diff(y) # length is n-1
# note y.diff[t] is y[t+1] - y[t], not y[t] - y[t-1],
# but when fitting MA model, such translation in time will not affect the results.
plot(1:(n-1), y.diff, type='l', xlab='time (month)')
acf(y.diff)
ma1 = arima(y.diff, order=c(0,0,1), method='CSS')
ma1
mu.hat = ma1$coef['intercept'] %>% as.numeric()
theta.hat = ma1$coef['ma1'] %>% as.numeric()
psi0 = mu.hat * (1-theta.hat+theta.hat^2-theta.hat^3)
psi1 = theta.hat
psi2 = -theta.hat^2
psi3 = theta.hat^3
c(psi0, psi1, psi2, psi3)
modar2.coef = c(psi0, 1+psi1, psi2-psi1, psi3-psi2, -psi3)
modar2.coef
modar$coefficients %>% as.numeric() # from the model in part a
k = 100
y.full2 = c(y, rep(-9999, k))
for (t in (n+1):(n+k)) {
y.full2[t] = sum(modar2.coef * c(1, y.full2[t-1], y.full2[t-2], y.full2[t-3], y.full2[t-4]))
}
plot(1:n, y, type='l', xlim=c(0,n+k))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
lines((n+1):(n+k), y.full2[(n+1):(n+k)], col='blue')
model.diff = y.full[(n+1):(n+k)] - y.full2[(n+1):(n+k)]
model.diff
#plot(1:k, model.diff, type='l')
model.diff = y.full[(n+1):(n+k)] - y.full2[(n+1):(n+k)]
plot(1:k, model.diff, type='l')
dat = read.csv('alc.csv')
y = dat[,2]
n = length(y)
plot(1:n, y, type='l')
p = 16
Xmat = matrix(nrow=n-p, ncol=p)
for(j in 1:p)
{
Xmat[,j] = y[(p-j+1):(n-j)]
}
modar = lm(y[(p+1):n] ~ Xmat)
summary(modar)
Dt = diff(diff(y, lag= 12))
#length(Dt) # n-13
plot(1:length(Dt), Dt, type='l')
acf(Dt)
ma1 = arima(Dt, order=c(0,0,1), method='CSS')
ma1
mu = ma1$coef[2] %>% as.numeric(); th = ma1$coef[1] %>% as.numeric()
psi0 = mu * (1-th+th^2-th^3)
psi1 = th
psi2 = -th^2
psi3 = th^3
c(psi0, psi1, psi2, psi3)
d.coef = rep(0, p+1) # coefficients for the second AR(16) model derived from Dt. The first entry is the intercept.
d.coef[1] = psi0
d.coef[2] = 1+psi1
d.coef[3] = psi2-psi1
d.coef[4] = psi3-psi2
d.coef[5] = -psi3
d.coef[13] = 1
d.coef[14] = -1-psi1
d.coef[15] = psi1-psi2
d.coef[16] = psi2-psi3
d.coef[17] = psi3
compare.matrix = matrix(-9999, nrow=p+1, ncol=2)
compare.matrix[,1] = modar$coefficients %>% as.numeric()
compare.matrix[,2] = d.coef
compare.matrix = matrix(-9999, nrow=p+1, ncol=2)
compare.matrix[,1] = modar$coefficients %>% as.numeric()
compare.matrix[,2] = d.coef
compare.matrix
k = 36
y.full2 = c(y, rep(-9999, k))
for (t in (n+1):(n+k)) {
y.full2[t] = sum(d.coef * c(1, y.full2[(t-1):(t-p)]))
}
y.full2[(n+1):(n+k)]
plot(1:n, y, type='l', xlim=c(0,n+k))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
lines((n+1):(n+k), y.full2[(n+1):(n+k)], col='blue')
plot(1:n, y, type='l', xlim=c(0,n+k))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
lines((n+1):(n+k), y.full2[(n+1):(n+k)], col='blue')
k = 36
y.full2 = c(y, rep(-9999, k))
for (t in (n+1):(n+k)) {
y.full2[t] = sum(d.coef * c(1, y.full2[(t-1):(t-p)]))
}
y.full2[(n+1):(n+k)]
plot(1:n, y, type='l', xlim=c(0,n+k))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
lines((n+1):(n+k), y.full2[(n+1):(n+k)], col='blue')
k = 36
y.full = c(y, rep(-9999, k))
phis = modar$coefficients %>% as.numeric()
for (t in (n+1):(n+k)) {
y.full[t] = sum(phis * c(1, y.full[(t-1):(t-p)]))
}
start=250
plot(start:n, y[start:n], type='l', xlim=c(start-1,n+k), ylim=c(3000, 8500))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
plot(1:n, y, type='l', xlim=c(0,n+k))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
lines((n+1):(n+k), y.full2[(n+1):(n+k)], col='blue')
compare.matrix = matrix(-9999, nrow=p+1, ncol=2)
compare.matrix[,1] = modar$coefficients %>% as.numeric()
compare.matrix[,2] = d.coef
compare.matrix
compare.matrix = matrix(-9999, nrow=p+1, ncol=2)
compare.matrix[,1] = modar$coefficients %>% as.numeric()
compare.matrix[,2] = d.coef
compare.matrix
k = 36
y.full2 = c(y, rep(-9999, k))
for (t in (n+1):(n+k)) {
y.full2[t] = sum(d.coef * c(1, y.full2[(t-1):(t-p)]))
}
y.full2[(n+1):(n+k)]
plot(1:n, y, type='l', xlim=c(0,n+k))
lines((n+1):(n+k), y.full[(n+1):(n+k)], col='red')
lines((n+1):(n+k), y.full2[(n+1):(n+k)], col='blue')
dat = read.delim("sunspot.txt", header = F, sep = "")
y = dat[,2]
n = length(y)
plot(1:n, y, type='l')
acf(y)
pacf(y)
ma = arima(ytrain, order=c(0,0,15), method='CSS')
ma$coef
ma = arima(ytrain, order=c(0,0,15), method='CSS')
ma$coef %>% as.numeric()
ma = arima(ytrain, order=c(0,0,15), method='CSS')
ma$coef
ntest=40
ntrain=n-ntest
ytrain = y[1:(n-ntest)]
ytest = y[(n-ntest+1):n]
ar.pred = matrix(-9999, nrow=ntest, ncol=15) # column p is predictions of AR(p) model
ar.mse = rep(-1, 15)
ma.pred = matrix(-9999, nrow=ntest, ncol=15) # column p is predictions of MA(p) model
ma.mse = rep(-1, 15)
# AR
for (p in 1:15) {
Xmat = matrix(nrow=ntrain-p, ncol=p)
for(j in 1:p)
{
Xmat[,j] = ytrain[(p-j+1):(ntrain-j)]
}
modar = lm(ytrain[(p+1):ntrain] ~ Xmat)
# make predictions
y.full = c(y, rep(-9999, ntest))
phis = modar$coefficients %>% as.numeric()
for (t in (ntrain+1):n) {
y.full[t] = sum(phis * c(1, y.full[(t-1):(t-p)]))
}
ar.pred[,p] = y.full[(ntrain+1):n]
# calculate mse
ar.mse[p] = mean((ytest - ar.pred[,p])^2)
}
# MA
for (p in 1:15) {
ma = arima(ytrain, order=c(0,0,p), method='CSS')
# make predictions
y.full = c(y, rep(-9999, ntest))
ma.coef = ma$coef %>% as.numeric() # intercept is at the end
for (t in (ntrain+1):n) {
y.full[t] = sum(ma$coef * c(y.full[(t-1):(t-p)], 1))
}
ma.pred[,p] = y.full[(ntrain+1):n]
# calculate mse
ma.mse[p] = mean((ytest - ma.pred[,p])^2)
}
ar.mse
ma.mse
ma.pred[,2]
ntest=40
ntrain=n-ntest
ytrain = y[1:(n-ntest)]
ytest = y[(n-ntest+1):n]
ar.pred = matrix(-9999, nrow=ntest, ncol=15) # column p is predictions of AR(p) model
ar.mse = rep(-1, 15)
ma.pred = matrix(-9999, nrow=ntest, ncol=15) # column p is predictions of MA(p) model
ma.mse = rep(-1, 15)
# AR
for (p in 1:15) {
Xmat = matrix(nrow=ntrain-p, ncol=p)
for(j in 1:p)
{
Xmat[,j] = ytrain[(p-j+1):(ntrain-j)]
}
modar = lm(ytrain[(p+1):ntrain] ~ Xmat)
# make predictions
y.full = c(y, rep(-9999, ntest))
phis = modar$coefficients %>% as.numeric()
for (t in (ntrain+1):n) {
y.full[t] = sum(phis * c(1, y.full[(t-1):(t-p)]))
}
ar.pred[,p] = y.full[(ntrain+1):n]
# calculate mse
ar.mse[p] = mean((ytest - ar.pred[,p])^2)
}
# MA
for (p in 1:15) {
ma = arima(ytrain, order=c(0,0,p), method='CSS')
ma.pred[,p] = predict(ma, n.ahead = ntest)
# calculate mse
ma.mse[p] = mean((ytest - ma.pred[,p])^2)
}
ma = arima(ytrain, order=c(0,0,15), method='CSS')
predict(ma, n.ahead = ntest)
ma = arima(ytrain, order=c(0,0,15), method='CSS')
predict(ma, n.ahead = ntest)$pred
ma = arima(ytrain, order=c(0,0,15), method='CSS')
predict(ma, n.ahead = ntest)$pred %>% as.numeric()
ntest=40
ntrain=n-ntest
ytrain = y[1:(n-ntest)]
ytest = y[(n-ntest+1):n]
ar.pred = matrix(-9999, nrow=ntest, ncol=15) # column p is predictions of AR(p) model
ar.mse = rep(-1, 15)
ma.pred = matrix(-9999, nrow=ntest, ncol=15) # column p is predictions of MA(p) model
ma.mse = rep(-1, 15)
# AR
for (p in 1:15) {
Xmat = matrix(nrow=ntrain-p, ncol=p)
for(j in 1:p)
{
Xmat[,j] = ytrain[(p-j+1):(ntrain-j)]
}
modar = lm(ytrain[(p+1):ntrain] ~ Xmat)
# make predictions
y.full = c(y, rep(-9999, ntest))
phis = modar$coefficients %>% as.numeric()
for (t in (ntrain+1):n) {
y.full[t] = sum(phis * c(1, y.full[(t-1):(t-p)]))
}
ar.pred[,p] = y.full[(ntrain+1):n]
# calculate mse
ar.mse[p] = mean((ytest - ar.pred[,p])^2)
}
# MA
for (p in 1:15) {
ma = arima(ytrain, order=c(0,0,p), method='CSS')
ma.pred[,p] = predict(ma, n.ahead = ntest)$pred %>% as.numeric()
# calculate mse
ma.mse[p] = mean((ytest - ma.pred[,p])^2)
}
ar.mse
ma.mse
which.min(ar.mse)
which.min(ma.mse)
best.p = which.min(ar.mse)
best.q = which.min(ma.mse)
ar.mse[best.p]
ma.mse[best.q]
best.p = which.min(ar.mse)
best.q = which.min(ma.mse)
ar.mse[best.p] # smaller
ma.mse[best.q]
best.p
ar.mse[15]
ar.mse[9]
plot(1:15, ar.mse)
plot(1:15, ar.mse)
plot(1:15, ar.mse, xlab='p')
plot(1:15, ar.mse, xlab='p', ylab='MSE of AR(p)')
